# BrickGame

[Build Status](https://hub.docker.com/r/andrejlevkovitch/brickgame/builds/) 


Реализация brick_game под Qt.

Имеется документация doxygen.


Основу всей программы составляют 3 класса:

screen - представляет собой представление игры на экране

abstractGame - интерфейс для постоения игр

general_window - окно, в котором открывается программа


Используется система ресурсов для всех сторонних данных. Используются 
stylesheets.


Все важные константы собраны в файле brick_game.hpp. Это:

  FIELD_SIZE - размеры поля

  MINI_FIELD_SIZE - размеры маленького поля в screen

  MINI_SCR_BGN - начало отсчета значений brick_game::point для мальнького поля

  Value - допустимые значения для поля (ИСПОЛЬЗУЙТЕ ТОЛЬКО ИХ)

  Direction - значения, которые пересылаются с событиями в custormEvent

  Event - евенты (не заморачивайтесь)

  LEVEL_DIGIN_COUNT - количество цифр для уровня (не более 99)

  SCORE_DIGIN_COUNT - количество цифр для очков (не более 999 999)

  HOME - каталог для хранения файлов
  

===============================================================================

Встречайте: класс abstractGame

Для того, чтобы избежать подключения коннектов каждый раз при установке новой
игры следует наследовать abstractGame который автоматически подключается к 
screen в general_window.

Этот класс является интерфейсом для создания игр, так что создаваемые игры должны
быть плагинами, динамически загружаемыми в программу. Образец для создания плагина
simplExempl.


Вам нужно переопределить несколько методов и слотов (см в abstractGame.hpp).

Методы:

  customEvent(::QEvent *) - использует события для управление игрой (смотрите пример
    реализации simpleExempl)

  game_name() - возвращает имя игры (БЕЗ ПРОБЕЛЬНЫХ СИМВОЛОВ!!!)


Слоты, которые также нужно переопределить:

  start_game_slot() - запускает вашу игру

  finish_game_slot() - завершает вашу игру


Также в этом классе имеются следующие сигналы, которые следует использовать для
общения с screen:

  end_game_signal(unsigned short, unsigned) - отсылает сигнал о том, что игра была прекращена и
    пересылает значения level и score (по умолчанию пересылает 0-и)

  pause_signal(bool) - если ваша игра поддерживает паузу, то высылайте этот сигнал
    после постановки на паузу (если true - игра на паузе, если false - игра 
    снята с паузы

  activity() - уведомление для плеера о звуковой активности

Они нужны для удобной проверки находится ли объект в пределах поля? (смотрите 
класс brick_game::point)


Имеется также не виртуальный метод 
  
  bool is_passible(brick_game::point) - простая реализация проверки выхода за
    пределы поля


И самое главное, конечно: объект классa field - по сути двумерный массив,
поле, с котором просто работать. Каждый элемент объекта field связан с 
соответствующим объектом pix на экране и, поэтому, при его изменении тут же
изменяется соответствующий элемент на экране. Обращение к элементам в field
такое же как и у двумерного массива: через [][], также, если Вы используете
координаты, то можно воспользовать методом, который принимает координаты и 
выдает нужное значение (field(::QPoint{1, 1})). Вам доступно два объекта данного
типа в классе abstractGame: field_ и mini_field_ - большое и малое поля
соответственно. Благодаря такому устроийству вам нет необходимости вручную 
передовать сигналы об изменении элемента поля - это происходит автоматически при
изменении этого элемента.

Также имеются объекты классов lavel и score - используйте их для указания уровня
и счета.

Если хотите добавить в вашу игру звуки, просто вставсте url к ресурсам в:

  begin_theme_sound_ - для мелодии на старте

  activity_sound_ - для звука некоторой активности (воспроизводится по сигналу 
    activity)

  score_sound_ - воспроизводится при изменении счета

  level_up_sound_ - воспроизводится при изменении уровня

Если хотите поставить иконку для вашей игры, укажите путь до нее в 

  icon_


===============================================================================


Пара слов о brick_game::point

Класс специально создан для легкого определения выхода за пределы поля. Для
этого у него определены операторы < и >. Работают они исходя из 2 и 4 четверти.
Тобишь, если правое значение находится во 2-ой четверти относительно левого, то
оно больше левого значения, и наоборот. Но ТОЛЬКО ДЛЯ 2-й и 4-й четвертей.

Автоматически приводится к ::QPoint


===============================================================================


Пара слов о screen

Cледует знать, что таблица рекордов в конце игры появляется только в
случае передачи сигнала из игры end_game_siganl. Поэтому в случае завершения
вашей игры принудительно (через screen) следует указать следующую конструкцию:

if (sender() != this) {
  emit end_game_signal(level, score);
  return;
}

после того, как будет выслан этот сигнал значения score_ и level_ обнулятся
